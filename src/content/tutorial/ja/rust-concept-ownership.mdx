---
title: Rustの所有権とライフタイム
date: "2024-06-18"
description: TODO
private: true
series: ja/rust-concept
tags:
  - Rust
---

## コピーセマンティクス

```rs title="例：コンパイルに成功するコード" showLineNumbers
fn main() {
  let s = 1;
  let t = s;

  println!("{}", s);
  println!("{}", t);
}
```

`t = s{:rs}`によって、

1. 新たに`i32`型の値を格納するメモリが確保される
2. そこに`s`の値がコピーされる
3. 新しく確保したメモリの値に`t`というラベルが付与される

このように、既存の変数と新しい変数を`=`で結びつけたときに、新たなメモリ領域が確保され、既存の変数の値を新たなメモリ領域にコピーする方式を**コピーセマンティクス**と呼ぶ。

`Copy`トレイトを実装している変数型には、コピーセマンティクスが適用される。

## ムーブセマンティクス

```rs title="例：コンパイルに失敗するコード" showLineNumbers
fn main() {
  let s = "hello".to_string();
  // move occurs （「移動」が発生した） // [!code error]
  // not implemented the `Copy` trait （Copyトレイトが実装されていない） // [!code error]

  let t = s;
  // value moved here // [!code error]

  println!("{}", s);
  println!("{}", t);
  // value borrowed here after move （「移動」の後に値が「借用」されている） // [!code error]
}
```

`t = s{:rs}`によって、

1. `s`が指し示していた値のラベルが`t`に変わる
2. `s`のラベルはどのメモリ領域も指さなくなる

これを「`s`が指し示していた値の**所有権**が、`s`から`t`に移動した」という。

このように、既存の変数と新しい変数を`=`で結びつけたときに、新たなメモリ領域の確保をせず、所有権を移動させて新しい変数のラベルに付け替える方式を**ムーブセマンティクス**と呼ぶ。

新しく作られた型にはデフォルトでムーブセマンティクスが適用される。

## 所有権によるGCの代替とメモリリークの防止

Rustでは、メモリ上に確保された値には「所有者」が設定されている。

- それぞれの値にはあるライフタイム（生存期間）を持ったただ一つの所有者（所有権を持つ変数）があり、所有権を持つ変数のみが値にアクセスできる
- どの値の所有者にもなっていない変数は「初期化されていない状態」になり参照できない

上の2つのルールを満たすかはコンパイル時にチェックされるため、メモリリークの危険が排除される。

- ライフタイムが終了した、または所有者がいなくなった値はメモリ上から直ちに破棄される

所有権という考え方により、メモリ上に格納された値とラベルである変数が一対一に対応する。
どの変数からも所有されていないメモリ上の値は不要と判断できるため、ガベージコレクションのような実行時のメモリ解放の仕組みが不要になる。

## 所有権の消費

### 関数の引数と所有権の移動

関数の中の変数に所有権が移動することを、**所有権を消費（consume）する**という。

```rs title="例：コンパイルに失敗するコード" showLineNumbers
fn myprint<T: std::fmt::Display>(msg: T) {
  println!("{}", msg);
}

fn main() {
  // ムーブセマンティクスが適用される変数
  let s = "hello".to_string();
  // move occurs // [!code error]

  // sの所有権が関数内の変数に移動
  myprint(s);
  // value moved here // [!code error]

  // sの所有権は移動してしまい、初期化されていない変数になるのでエラー
  myprint(s);
  // value used here after move // [!code error]
}
```

ムーブセマンティクスが適用される変数`s`を関数の引数に渡すと：

1. `s`が持っていた所有権が関数内の変数`msg`に移動する
2. `s`は初期化されていない状態になり、再度使うことはできなくなる
3. 1回目の`myprint`関数を抜けたところで、`msg`に移動した所有権のライフタイムは終了する
4. その時点でメモリの解放が行われ、メモリから値そのものがなくなる

### cloneによる回避

関数実行が終わってからも変数を参照したい場合は、関数の引数に渡す前にコピーを作っておくことで、引数に渡した変数の所有権は消費されても、引数に渡さなかったコピーを参照し、元の変数の情報を得ることができる。

```rs title="例：コンパイルに成功するコード" {9-10} showLineNumbers
fn myprint<T: std::fmt::Display>(msg: T) {
  println!("{}", msg);
}

fn main() {
  // ムーブセマンティクスが適用される変数
  let s = "hello".to_string();

  // sのコピーをssに作っておく
  let ss = s.clone();

  // sの所有権が関数内の変数に移動
  myprint(s);

  // ssの所有権が関数内の変数に移動
  myprint(ss);
}
```

しかし、コピーするデータ量が大きくなると、無駄なメモリコピーを減らそうとするムーブセマンティクスのメリットを潰してしまう。

## リファレンス

### 所有権の消費をコピーせずに回避する

ムーブセマンティクスが適用される変数の所有権を移動させずに、関数の引数などで使えるようにするには、**リファレンス**を使う。

```rs title="例：コンパイルに成功するコード" showLineNumbers /&T/ /*msg/ /&s/
fn myprint<T: std::fmt::Display>(msg: &T) {
  // リファレンスによってmsgを受け取る
  println!("{}", *msg);
}

fn main() {
  // ムーブセマンティクスが適用される変数
  let s = "hello".to_string();

  // リファレンスによって関数に渡している
  myprint(&s);

  // sが所有権を失わないので2回実行できる
  myprint(&s);
}
```

`&s`は、「変数`s`が所有している値のリファレンス」と呼ばれる。
リファレンスは、値を指し示すことのできる情報（＝メモリアドレス）を持った別の値である。

### 所有権の借用

値にアクセスするためには所有権が必要だが、リファレンスを関数の引数に渡した場合、そのリファレンスを受け取った関数内の変数は、所有権を一時的に **借用（borrow）** する。
所有権を借用した変数は、リファレンスを通じて値にアクセスできるようになる。

### デリファレンス（参照外し）

リファレンスから、それが指し示す値にたどることを**デリファレンス**という。
デリファレンスをするときは、リファレンスの値に束縛された変数の前に`*`演算子をつける。

## イミュータブルなリファレンス

同じ値に対するイミュータブルなリファレンスは複数作成できる。

```rs title="例：コンパイルに成功するコード（抜粋）" showLineNumbers
fn main() {
  let s = "hello".to_string();

  let s_ref = &s;
  let s_ref2 = &s;

  // リファレンスを関数に渡している
  myprint(s_ref);
  // sが所有権を失わないので2回実行できる
  myprint(s_ref);

  // リファレンスを関数に渡している
  myprint(s_ref2);
  // sが所有権を失わないので2回実行できる
  myprint(s_ref2);
}
```

## ミュータブルなリファレンス

リファレンスとして関数に渡した変数の値が関数の中で変更される場合には、`&mut`を変数の前につけて、ミュータブルなリファレンスとして関数に渡すようにする。

```rs title="例：コンパイルに成功するコード" showLineNumbers /&mut/
fn myclear(x: &mut String) {
  x.clear();
}

fn main() {
  let mut s = "hello".to_string();
  println!("s = {}", s);

  let s_ref = &mut s;
  myclear(s_ref);
  println!("s = {}", s);
}
```

同じ値に対するミュータブルなリファレンスは、複数作成することはできない。

```rs title="例：コンパイルに失敗するコード" showLineNumbers
fn myclear(x: &mut String) {
  x.clear();
}

// cannot borrow `s` as mutable more than once at a time // [!code error]
fn main() {
  let mut s = "hello".to_string();
  println!("s = {}", s);

  let s_ref = &mut s;
  let s_ref2 = &mut s;

  myclear(s_ref);
  println!("s = {}", s);
}
```

**同じ値に対する複数のミュータブルなリファレンスは存在できない**ことにより、次のような問題を回避できる。

- あるリファレンス型の変数を通じて値を変更したときに、別のリファレンス型の変数が参照している値が知らぬ間に変わってしまう
- 複数スレッドで実行する際に、ある値を意図せずに同時に変更しようとする競合が生じる

## リファレンスのスコープ

リファレンスのスコープは、そのリファレンスが最後に使われたところで終わる。

### スコープが重ならないミュータブルなリファレンス

ミュータブルなリファレンスは、スコープが重ならなけば複数存在できる。

```rs title="例：コンパイルに成功するコード" showLineNumbers
fn myclear(x: &mut String) {
  x.clear();
}

fn main() {
  let mut s = "hello".to_string();
  println!("s = {}", s);

  // --- start: s_refのスコープ
  let s_ref = &mut s;
  myclear(s_ref);
  // --- end: s_refのスコープ

  println!("s = {}", s);

  // --- start: s_ref2のスコープ
  let s_ref2 = &mut s;
  myclear(s_ref2);
  // --- end: s_ref2のスコープ

  println!("s = {}", s);
}
```

### リファレンスのスコープ内での値の更新

ミュータブルな変数に束縛している値であっても、その値のリファレンスのスコープの中では値の更新ができない。

```rs title="❌ 所有権を貸し出しているミュータブルな変数を更新しようとする" showLineNumbers
// cannot assign to `x` because it is borrowed // [!code error]
fn main() {
  let mut x = 1;

  // --- start: x_refのスコープ
  let x_ref = &x;

  x = 2;

  println!("{}", x_ref);
  // --- end: x_refのスコープ
}
```

リファレンスのスコープ内では、元の変数は所有権を他の変数に貸し出していて、所有権を一時的に失っている状態になっているため、所有権を持っていた値を変更できない。

## ライフタイムとリファレンス

### 破棄されてしまった値のリファレンス

スコープ外に出て破棄されてしまった値のリファレンスは存在してはならない。

```rs title="❌ 関数内のローカル変数へのリファレンスを返却値にする" showLineNumbers
fn return_hello() -> &String {
  // this function's return type contains a borrowed value, // [!code error]
  // but there is no value for it to be borrowed from // [!code error]
  // （この関数の返却値の型には借用された値が含まれているが、借用された値が存在しない） // [!code error]
  let s = "hello".to_string();
  &s
}

fn main() {
  let s = return_hello();
  println!("{}", s);
}
```

関数`return_hello`内で宣言されているローカル変数`s`は、この関数の実行が終わるとその値がメモリから破棄される。
そのため、返却されたリファレンス`&s`が指し示す値は、関数の外ではすでに破棄されてしまっている。

### リファレンスのスコープと変数のスコープ

リファレンスは、参照する元の変数の所有権のライフタイムを超えて使うことができない。

リファレンスが指し示す値は、そのリファレンスよりも長生きしている必要がある。
つまり、**リファレンスのスコープは、参照する元の変数のスコープよりも小さい必要がある**。

```rs title="❌ 値を所有する変数のスコープの外でその値に対する参照を行う" showLineNumbers
// `y` does not live long enough // [!code error]
// （yは十分に長く存在していない） // [!code error]
fn main() {
/* --- start: リファレンスxのスコープ --- */
  let x;

  {
  /* --- start: 参照する変数yのスコープ --- */
    let y = 1;
    x = &y;
     // ^^ borrowed value does not live long enough // [!code error]
  /* --- end: 参照する変数yのスコープ --- */
  }
  // `y` dropped here while still borrowed // [!code error]

  println!("{}", x);
              // - borrow later used here // [!code error]
/* --- end: リファレンスxのスコープ --- */
}
```

5行目で`y`に束縛した`1`は、このブロックが終わる7行目でメモリから破棄される。
つまり、9行目では破棄された値に対するリファレンスを使おうとしていることになる。

## ライフタイムパラメータ

### 引数と返却値がリファレンスの関数定義

```rs title="❌ 2つのリファレンスを引数として、2つのリファレンスを返す関数" showLineNumbers
fn pick2(x: &[i32], y: &[i32], end: usize) -> (&[i32], &[i32]) {
  // this function's return type contains a borrowed value, // [!code error]
  // but the signature does not say whether it is borrowed from `x` or `y` // [!code error]
  // -> この関数の返却値の型は借用された型を含んでいる。 // [!code error]
  // しかし、関数の定義からは2つの引数xとyのどちらから借用しているのかわからない // [!code error]
  (&x[..end], &y[..end])
}
```

関数のローカル変数のリファレンスを返却値とすることはできないため、返却値のリファレンスは、

- 引数のリファレンスを起源としたもの
- 静的領域に配置される、プログラム実行時にいつでも有効な値のリファレンス（`&'static`）

のいずれかになる。

そのため、返却値と引数が参照する元の値は、同時にメモリに存在していて破棄されていない（同時にライフタイムの中にいる）必要がある。

```rs title="✅ ライフタイムパラメータを指定" showLineNumbers /a/ /b/
fn pick2<'a, 'b>(x: &'a [i32], y: &'b [i32], end: usize) -> (&'a [i32], &'b [i32]) {
  (&x[..end], &y[..end])
}
```

ライフタイムパラメータが同じリファレンスは、それぞれの参照元の値が同時にライフタイムの中にあって、同時に参照することが可能である、とコンパイラに認識される。

引数にも返却値にもリファレンスが現れる場合には、それらが同時に生存しているか否かを示すために、ライフタイムパラメータの指定が必要になる。

### ライフタイムパラメータの省略

引数に現れるリファレンスが1つであれば、引数に現れるリファレンスと返却値に現れるすべてのリファレンスは同じライフタイムを持つ、と推定される。

```rs title="✅ ライフタイムパラメータを省略してもよい" showLineNumbers
fn pick1(x: &[i32], end: usize) -> &[i32] {
  &x[..end]
}
```

## 関数の引数における値とリファレンス

### ムーブセマンティクスの場合

ムーブセマンティクスが適用される変数を関数の引数に渡す場合は、所有権の移転を伴わずに値を渡すため、リファレンスによる所有権の借用を使う。

### コピーセマンティクスの場合

コピーセマンティクスが適用される変数を関数の引数に渡す場合は、2つの選択肢がある。

- その値の所有権を持つ変数を引数に渡す
- 所有権を借用したリファレンスを引数に渡す

```rs title="✅ 所有権を持つ変数を引数に渡す" showLineNumbers
fn incr_by_owned(x: i32) -> i32 {
  x + 1
}

fn main() {
  let x = 1;
  println!("{}", incr_by_owned(x));
}
```

```rs title="✅ 所有権を借用したリファレンスを引数に渡す" showLineNumbers /&x/ /*x_ref/
fn incr_by_ref(x_ref: &i32) -> i32 {
  *x_ref + 1
}

fn main() {
  let x = 1;
  println!("{}", incr_by_ref(&x));
}
```

どちらの関数でも、引数の内容はスタック領域と呼ばれるメモリにコピーされるが、コピーする内容に違いがある。

- `incr_by_owned`は、`x`に対応する値そのものをコピー
- `incr_by_ref`は、`x`のリファレンスの値（メモリアドレス）をコピー

また、関数内で必要になる処理にも違いがある。

- `incr_by_owned`では、スタック領域にコピーされた値をそのまま演算に使える
- `incr_by_ref`では、リファレンスから値をたどって取り出すでリファレンスが必要になる

**引数のスタックへのコピーにかかる時間の差**と、**デリファレンスの時間**により、どちらが高速に実行できるかが決まってくる。

- 大きな構造体などは、リファレンスを渡した方が有利：
  - 引数に渡す変数に束縛されている値のデータ量が大きい場合は、スタック領域への値のコピーに時間がかかる。
- プリミティブ型の変数は、値を渡した方が有利：
  - スタックへのコピー量はほぼ同じで、デリファレンスをするコストが余分にかかる。
