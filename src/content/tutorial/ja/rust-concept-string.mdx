---
title: 文字列
date: "2024-06-20"
description: TODO
private: true
series: ja/rust-concept
tags:
  - Rust
---

## 文字型

### 文字リテラル

シングルクォーテーションで囲んだ1文字は文字リテラルとなり、束縛された変数は`char`型と推論される。

```rs title="文字リテラル"
let c = 'c';
let a = 'あ';
```

### バイト列への変換

Rustの`char`型はユニコード（最大4バイト）の1文字であり、1バイトとは限らないため、

- `char`から`u32`への変換はメソッドが用意されている
- `char`から`u8`への変換は対応していない（情報を失わずに変換できる保証がない）

## 文字列型

### 文字列リテラル

ダブルクォーテーションで囲んだ複数文字は文字列リテラルとなり、束縛された変数は`&'static str`型と推論される。

```rs title="文字列リテラル"
let s = "hello";
```

### 静的領域とライフタイム

文字列リテラルが示す文字列は、プログラム実行の初期にメモリの**静的領域**に配列のように配置され、そのスライスとなる。

静的領域は、プログラムの起動から最後まで割り当てられていて、サイズが不変な**静的変数**を配置する領域。
`static`をつけて宣言した変数もこの領域に配置される。

文字列リテラルの値はプログラムの起動から最後までメモリに置かれているため、ライフタイムパラメータは`'static`になっている。

### スライスとして扱う

`&str`型はスライスであるため、スライスと同様の記法で一部分の取り出しができる。

```rs title="✅ 英文字列の最初の2文字を取り出す" showLineNumbers
fn main() {
  let s = "hello";
  println!("{}", &s[0..2]);
}
```

`&str`は`&[u8]`と同じであるため、マルチバイト文字のスライスもバイト単位での指定になる。

```rs title="✅ 日本語文字列の最初の2文字を取り出す" showLineNumbers
fn main() {
  // UTF-8では、「あいうえお」の各文字は3バイト
  let s = "あいうえお";
  // 6バイト取り出せば、2文字分になる
  println!("{}", &s[0..6]);
}
```

このとき、スライスの境界が文字境界と一致している必要がある。

```rs title="❌ スライスに指定したバイト数が、1文字のバイト数の倍数になっていない" showLineNumbers
fn main() {
  // UTF-8では、「あいうえお」の各文字は3バイト
  let s = "あいうえお";
  // 5バイトは何文字分…？
  println!("{}", &s[0..5]);
  // byte index not a char boundary; // [!code error]
  // it is inside `い` (bytes 3..6) of `あいうえお` // [!code error]
}
```

マルチバイト文字を含む`&str`型を扱う場合は、次のようなメソッドを使うと便利。

- `chars(){:rs}`：文字境界で分割して`char`型を返すイテレータを生成する
- `as_bytes(){:rs}`：文字境界にかかわらずバイト列のスライスを作る

## String型

`&str`型は文字の追加などはできないため、文字列操作を容易にする高機能版として`String`型がある。

```rs title="文字列リテラルからString型の変数を作成 - 1"
// &strからStringに変換
let str = "hello".to_string();
```

```rs title="文字列リテラルからString型の変数を作成 - 2"
// &strからStringに変換
let str = String::from("hello");
```

- `String`型には、文字列操作のメソッドが多数用意されている
- スライス記法を使うことも可能
- `String`型のリファレンス`&String`は、ライフタイムパラメータが`'static`ではない`&str`型と同等
