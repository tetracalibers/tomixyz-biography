---
title: ダイナミックな型
date: "2024-06-25"
description: TODO
private: true
series: ja/rust-concept
tags:
  - Rust
---

## エラーの伝搬

### ?によるエラーの伝搬

ある関数Aの中で別の関数Bを呼び出してBにエラーが発生したとき、関数Aの処理はBの呼び出し時点で中止して関数Aの結果もエラーにしたい、というケースがある。
これは、**関数Bのエラーを関数Aに伝搬させている**ことになる。

このようなエラーの伝搬をさせたいときには、`Result<T, E>{:rs}`型を返す関数の呼び出しの末尾に`?{:rs}`をつける。

関数Aが関数Bを呼び出しているときに、関数Bの呼び出しの末尾に`?{:rs}`をつけると、

- 関数Bの結果が正常の場合：
  - `unwrap(){:rs}`を適用した状態と同じになる
- 関数Bの結果がエラーの場合：
  1. 関数Aの処理はそこで中止する
  2. 関数Bのエラーの値をそのまま関数Aのエラーの値とする

関数Bのエラーの値がそのまま関数Aのエラーの値となる可能性があるため、関数Aと関数Bでは、`Result<T, E>{:rs}`の`E{:rs}`の型が同じである必要がある。

### 複数のエラーの型をまとめて扱う

しかし、`?{:rs}`つきで呼ばれる関数が複数ある場合、`E{:rs}`の型が異なることもあり得る。

```rs title="✅ ファイルから読み出した数を使って割り算" showLineNumbers /?/ /Box<dyn std::error::Error>/ {19,26,28}
enum DivError {
  // 0で割り算した場合、分子を包んでエラーとして返す
  DivByZero(i32),
  // 分子・分母ともに負の数だった場合、分子・分母を包んでエラーとして返す
  BothNegative(i32, i32),
}

fn mydiv(x: i32, y: i32) -> Result<i32, DivError> {
  if y == 0 {
    Err(DivError::DivByZero(x))
  } else if x < 0 && y < 0 {
    Err(DivError::BothNegative(x, y))
  } else {
    Ok(x / y)
  }
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
  let f = File::open("./input.txt")?; // E = std::io::Error
  let f = BufReader::new(f);

  for line in f.lines().flatten() {
    let mut v = Vec::new();
    for ee in line.split(' ') {
      // parseメソッドで文字列から整数型に変換
      v.push(ee.parse()?); // E = <i32 as FromStr>::Err
    }
    let result = mydiv(v[0], v[1])?; // E = DivError
    println!("{} / {} = {}", v[0], v[1], result);
  }

  Ok(())
}
```

異なる`E{:rs}`型を持つ3つの関数を呼び出す側である`main{:rs}`関数では、`E{:rs}`型を`Box<dyn std::error::Error>{:rs}`としている。
これは、「`std::error::Error{:rs}`トレイトを満たす型」を意味する**トレイトオブジェクト**であり、複数のエラーの型をまとめて扱うことを可能にしている。

## トレイトオブジェクト

**トレイト**は、ある動作に関連するメソッドを列挙し、それらのメソッドを実装している型をグループ化するもので、ジェネリクスの型パラメータの制約であるトレイト境界に使うものである。

トレイトそのものは型ではないが、「そのトレイトを満たす型」のように、関数の返却値などの型指定に使えたら便利な場合がある。
このような型指定として使えるのが、**トレイトオブジェクト**である。

### 実行時に決まる型

例えば、ある関数がエラーの内容によって異なる型を返す場合、実行してみないとどの型のエラーが実際に発生するかがわからないため、型をコンパイル時に確定することができない。

このようなときには、エラーの型が共通で実装している「`std::error::Error{:rs}`トレイトを実装している型」という形式で型の指定を行う。

これがトレイトオブジェクトであり、

- `Box<dyn std::error::Error>{:rs}`
- `& dyn std::error::Error{:rs}`

という形で型の指定をする。

`dyn{:rs}`は**dynamic**から取られたもので、**動的に型が決まる**ことを示すキーワードである。

### 使えるメソッドの制限

「`std::fmt::Debug{:rs}`トレイトを実装している型」というトレイトオブジェクトを要素とするベクター型を作成する。

```rs title="✅ 異なる型を要素とするベクターを作る" showLineNumbers /Box<dyn std::fmt::Debug>/
fn main() {
  let mut v = Vec::<Box<dyn std::fmt::Debug>>::new();

  v.push(Box::new(1_i32));
  v.push(Box::new(2_i32));
  v.push(Box::new(3.0_f64));
  v.push(Box::new(String::from("hello")));

  println!("{:?}", v);
}
```

`v{:rs}`の要素は「`std::fmt::Debug{:rs}`トレイトを実装している」という共通点があるため、`println!("{:?}", v);{:rs}`という出力が可能である。

しかし、トレイトオブジェクトによって指定された型は、指定したトレイトを実装していることしかコンパイラにはわからないため、これらの値に対して使えるメソッドは、指定したトレイトのメソッドのみになる。

例えば、`v{:rs}`の最初の要素`v[0]{:rs}`から`Box{:rs}`の中身を取り出した`*v[0]{:rs}`の値は`1_i32{:rs}`だが、これは`dyn std::fmt::Debug{:rs}`型の値であり、`i32{:rs}`型の値ではない。

## ゼロコスト抽象化

### 動的ディスパッチ

トレイトオブジェクトによって指定される型は、コンパイル時には1つに確定しない。

しかし、取り得る具体的な型の候補をコンパイル時に列挙することは可能であり、候補の型のメソッドがコンパイルされることになる。

実行時には、コンパイルされた複数の候補の中からどのメソッドを使うのかを検索して決定する必要があり、このようなメソッドの実行は**動的ディスパッチ**と呼ばれている。

動的ディスパッチでは、候補の型の **仮想関数テーブル（vtable）** を検索して実行しているメソッドを選択しているため、その検索のためのオーバーヘッドがかかる。

### 静的ディスパッチ

一方、トレイトオブジェクトを使わない場合には、コンパイルのときに具体的な型が確定しているため、その型に対応したメソッドがコンパイルされ、実行時に使うメソッドも確定している。

型パラメータ`T{:rs}`を含むジェネリクスの場合でも、`T{:rs}`がどの型になり得るのかをコードから判断し、それらの具体的な型に対するものが作られる。

```rs title="✅ ジェネリクスな関数とその使用" showLineNumbers
fn generic_return_type<T: srd::fmt::Display>(x: T) -> T {
  x
}

fn main() {
  println!("{}", generic_return_type(1));
  println!("{}", generic_return_type("hello"));
}
```

例えば、上のコードでは、コンパイル時に`generic_return_type::<i32>(){:rs}`と`generic_return_type::<&str>(){:rs}`が作成され、呼び出しができるようになる。

実行時にどのメソッドを使うのかを選択する必要がないメソッドの実行は、**静的ディスパッチ**と呼ばれている。

### 抽象化とオーバーヘッド

静的ディスパッチでは「実行時に実行するメソッドを選ぶ」というオーバーヘッドがかからないため、一般に動的ディスパッチよりも高速にプログラムを実行することができる。

抽象化を実行時のオーバーヘッドなしに実現することは**ゼロコスト抽象化**と呼ばれる。
Rustでは抽象化をしてもほとんどの場面で静的ディスパッチになっているため、ゼロコスト抽象化を実現しているといえる。
