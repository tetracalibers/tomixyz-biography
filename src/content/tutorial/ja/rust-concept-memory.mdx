---
title: メモリへの値の配置とボックス化
date: "2024-06-21"
description: TODO
private: true
series: ja/rust-concept
tags:
  - Rust
---

## メモリの領域

メモリは次の4つの領域に大きく分けられる。

- **テキスト領域**：機械語に翻訳されたプログラムがロードされる領域
- **静的領域**：グローバル変数や静的変数に束縛された値を格納する領域
- **スタック領域**：コンパイル時にサイズが決まるものが置かれる領域
- **ヒープ領域**：プログラムの実行中に動的に確保されてデータが置かれる領域

関数の中で`let`で変数に束縛する値（ローカル変数）は、基本的にスタック領域に置かれる。

## Vec型の裏側（生ポインタの隠蔽）

スタック領域に置かれる値はコンパイル時にサイズが決まっている必要があるが、`Vec<T>`型はプログラムの実行中に長さを変化させることができる。

`Vec<T>`型は生ポインタとサイズを保持した構造体になっている。

```rs title="構造体Vecの定義"
struct Vec<T> {
  // ヒープ領域に動的に確保されたメモリ領域の先頭アドレスを指し示す生ポインタ
  buf: *const T,
  // サイズ
  len: usize,
}
```

ポインタとサイズという小さなデータがスタック領域に置かれ、本体のデータが置かれているのは動的に確保されたヒープ領域になっている。

要素が追加され、確保していた領域では足りなくなると、

1. ヒープ領域の再確保
2. 再確保した領域への既存のデータのコピー

がという操作が生ポインタを通じて行われる。

`Vec<T>`型の値を所有する変数のライフタイムが終われば、スタック上の生ポインタ・サイズと、生ポインタが指し示すヒープ領域のメモリが解放される。

## ヒープ領域にデータを配置する

通常の`let`による束縛では、値はスタック領域に置かれる。

プログラマがあえてヒープ領域にデータを配置したい場合もあるが、生ポインタは所有権管理の範疇にないため、生ポインタを通じた操作は安全ではない。

### Box型による生ポインタ操作の回避

`Box<T>`型を使うことで、生ポインタを直接使わずにヒープ領域にデータを配置することができる。

```rs title="✅ Box型を使ってヒープ領域にデータを配置する" showLineNumbers
fn main() {
  // スタック領域の値をboxedに束縛
  let boxed = Box::new(1);
  // *演算子でヒープ領域の値を取り出す
  let value = *boxed;

  println!("value = {}", value);
}
```

- `1`という値はヒープ領域に配置されている
- その値へのポインタと関連データがスタック領域に配置されている

`Box<T>`型の値を所有する変数のライフタイムが終われば、確保されたヒープ領域は解放される。

### ボックス化とその用途

`Box<T>`型を使って`T`型の値をヒープ領域に配置することを**ボックス化**という。

データのサイズがコンパイル時に決まらないデータは、データ自体はヒープ領域に置きつつ、コンパイル時にサイズが決まるデータだけをスタック領域に置く必要がある。

具体的には、

1. データをボックス化してヒープ領域に配置
2. ポインタだけをスタック領域に配置

のようにすることで、スタック領域に置くデータのサイズはコンパイル時に決めることができる。

### ボックス化による再帰的構造の実現

構造体や列挙型を再帰的に定義した場合、コンパイラがスタック領域に配置するのに必要なサイズが算出できず、エラーとなる。

```rs title="❌ 列挙型を再帰的に使用" showLineNumbers
// recursive type `RecursiveEnum` has infinite size // [!code error]
// -> 再帰的な型RecursiveEnumはサイズが無限である // [!code error]
use crate::RecursiveEnum::{Val, Null};

#[derive(Debug)]
enum RecursiveEnum {
  // ^^^^^^^^^^^^^ recursive type has inifiable size // [!code error]
  Val(RecursiveEnum),
  //  ^^^^^^^^^^^^^ recursive without indirection // [!code error]
  Null
}

fn main() {
  let x = Val(Val(Null));
  println!("{:?}", x);
}
```

ボックス化することで、スタック領域に確保するのに必要なのは生ポインタだけになり、スタック領域に確保すべきサイズがコンパイル時に決定できるようになる。

```rs title="✅ 再帰的な列挙型をボックス化で実現" showLineNumbers {5,10}
use crate::RecursiveEnum::{Val, Null};

#[derive(Debug)]
enum RecursiveEnum {
  Val(Box<RecursiveEnum>),
  Null
}

fn main() {
  let x = Val(Box::new(Val(Box::new(Null))));
  println!("{:?}", x);
}
```

## 定数値と静的変数

### 値をメモリ上に配置しない定数値

`const`は定数として宣言することを示す。
値のメモリ上への配置はせず、コンパイル前にコード上でその定数値に置き換えられる。

- コンパイル時に値が決まっていて、計算可能であればコンパイル時に計算される
- 実行時にメモリを参照することがない

繰り返しその値を使うのであれば、メモリ上に置いた値を参照するよりも高速に動作する可能性がある。

メモリへの配置はされないため、`&`を使ったリファレンスは作ることができない。

### 静的領域に値を配置する静的変数

`static`は静的変数として変数を宣言することを示し、メモリの静的領域に配置される。

プログラム実行中は最初から最後までメモリ上に存在するため、リファレンスを作って所有権を借用することができ、ライフタイムパラメータは`'static`となる。

静的変数をミュータブルな変数として値を束縛することは可能だが、静的変数を更新する操作は`unsafe`となる。

```rs title="✅ 静的変数を更新する" showLineNumbers
fn add_static() {
  const INCREMENT: usize = 2;
  static mut ADD: usize = 1;

  unsafe {
    ADD += INCREMENT;
    println!("add = {}", ADD);
  }
}

fn main() {
  add_static();
  add_static();
  add_static();
}
```

3行目の`ADD`の宣言は、静的領域に値を最初にセットする際の初期値であり、`add_static()`が呼ばれるたびに値がセットされるわけではない。

そのため、上の例の実行結果は、

```log title="💭 仮に関数呼び出しのたびに値がセットされるとしたら…"
add = 3
add = 3
add = 3
```

ではなく、

```log title="💻 実際の実行結果"
add = 3
add = 5
add = 7
```

となる。

### プログラム内での定数値と静的変数

`const`・`static`ともに、

- グローバルにも関数ローカルにも宣言できる
- 型推論は働かないため、型アノテーションは必須
- すべて大文字で書くことが推奨されている

```rs title="✅ 定数値と静的変数の操作" showLineNumbers
// グローバルに宣言
const BUFSIZE: usize = 1024;
static OFFSET: usize = 15;

fn add_static() {
  // 関数ローカルに宣言
  const INCREMENT: usize = 2;
  static mut ADD: usize = 1; // 静的変数はミュータブルとして宣言可能

  // 静的変数の更新はunsafe
  unsafe {
    ADD += INCREMENT;
    println!("add = {}", ADD);
  }
}

fn main() {
  // 静的変数はリファレンスを作ることができる
  let offset_ref = &OFFSET;

  println!("bufsize = {}", BUFSIZE);
  println!("offset = {}", offset_ref);

  add_static();
}
```
